#!/usr/bin/python
import sys, getopt
import argparse

"""
Sample API application,
Connect to TRex
Send UDP packet in specific length
Each direction has its own IP range
Compare  Rx-pkts to TX-pkts assuming ports are loopback

"""

import stl_path
from trex.stl.api import *
#from ...utils.text_tables import *

H_VER = "trex-x v0.1 "

class t_global(object):
     args=None;


import time
import json
import string

def validate_IP_dict(ip_dict):
    try:
        ip = ast.literal_eval(ip_dict)
        if not isinstance(ip, dict):
            raise argparse.ArgumentTypeError('Dictionary is expected.')
    except:
        raise argparse.ArgumentTypeError("Couldn't evaluate {} to dictionary.".format(ip_dict))
    if "start" not in ip or "end" not in ip:
        raise argparse.ArgumentTypeError("The dictionary must contain the following keys: (\"start\", \"end\").")
    if not (is_valid_ipv4(ip["start"]) and is_valid_ipv4(ip["end"])):
        raise argparse.ArgumentTypeError("Start and End values must be valid Ipv4 addresses.")
    return ip

def generate_payload(length):
    word = ''
    alphabet_size = len(string.ascii_letters )
    for i in range(length):
        word += string.ascii_letters [(i % alphabet_size)]
    return word


# simple packet creation
def create_pkt (frame_size = 9000, direction=0):

    ip_range = {'src': {'start': "10.0.0.1", 'end': "10.0.0.254"},
                'dst': {'start': "8.0.0.1",  'end': "8.0.0.254"}}

    if (direction == 0):
        src = ip_range['src']
        dst = ip_range['dst']
    else:
        src = ip_range['dst']
        dst = ip_range['src']

    vm = [
        # src
        STLVmFlowVar(name="src",min_value=src['start'],max_value=src['end'],size=4,op="inc"),
        STLVmWrFlowVar(fv_name="src",pkt_offset= "IP.src"),

        # dst
        STLVmFlowVar(name="dst",min_value=dst['start'],max_value=dst['end'],size=4,op="inc"),
        STLVmWrFlowVar(fv_name="dst",pkt_offset= "IP.dst"),

        # checksum
        STLVmFixIpv4(offset = "IP")
        ]

    pkt_base  = Ether(src="00:00:00:00:00:01",dst="00:00:00:00:00:02")/IP()/UDP(dport=12,sport=1025)
    pyld_size = frame_size - len(pkt_base);
    pkt_pyld   = generate_payload(pyld_size)

    return STLPktBuilder(pkt = pkt_base/pkt_pyld,
                         vm  = vm)

def format_number(num):
    if num < 0.001:
        return f"0"
    elif num < 1000:
        return f"{num:.3f}"
    elif num < 1000**2:  # 1,000,000
        return f"{num/1000:.3f}K"
    elif num < 1000**3:  # 1,000,000,000
        return f"{num/1000**2:.3f}M"
    else:
        return f"{num/1000**3:.3f}G"

def display_cpu_util_and_throughput(Stlclient, duration, port, pkt_len):
    step = 10
    while duration > 0:
        port_id = port
        RpcCmdData = namedtuple('RpcCmdData', ['method', 'params', 'api_class'])
        Stlclient.ports[port_id].stats.rpc_cmd = RpcCmdData('get_port_stats', {'port_id': port_id }, '')
        Stlclient.ports[port_id].stats.update_sync(Stlclient.conn.rpc)
        port_stat = Stlclient.ports[port_id].stats.latest_stats

        if port_stat:
            # Use formatted string for values
            print(f"{port_id:<10} {pkt_len:<10} {port_stat['m_cpu_util']:.3f}%     {format_number(port_stat['m_total_tx_pps']):<10} "
                  f"{format_number(port_stat['m_total_tx_bps']):<10} {format_number(port_stat['m_tx_util']):<10} "
                  f"{format_number(port_stat['m_total_rx_pps']):<10} {format_number(port_stat['m_total_rx_bps']):<10}")

        time.sleep(step)
        duration -= step

def simple_burst (duration, throughput):
    frame_size, speed = throughput
    if (frame_size < 60):
        frame_size = 60

    pkt_dir_0 = create_pkt (frame_size - 4, 0)

    #pkt_dir_1 = create_pkt (frame_size, 1)

    # create client
    c = STLClient(server = t_global.args.ip)

    passed = True

    try:
        tx_ports = [3, 1]
        # create two streams
        s1 = STLStream(packet = pkt_dir_0,
                       mode = STLTXCont())

        # connect to server
        c.connect()

        # prepare our ports (my machine has 0 <--> 1 with static route)
        c.reset(ports = tx_ports)

        # add both streams to ports
        c.add_streams(s1, ports = tx_ports[0])
        c.add_streams(s1, ports = tx_ports[1])
        #c.util_stats.update_sync(Stlclient.conn.rpc)
        # clear the stats before injecting
        c.clear_stats()

        # choose rate and start traffic for 10 seconds on 5 mpps
        for port in tx_ports:
            # Use formatted string for headers
            c.start(ports = [port], mult = speed, duration = duration)
            display_cpu_util_and_throughput(c, duration, port, frame_size)
        # block until done
        c.wait_on_traffic(ports = tx_ports)

        # read the stats after the test
        #stats = c.get_stats()

        #lost_a = stats[0]["opackets"] - stats[1]["ipackets"]
        #lost_b = stats[1]["opackets"] - stats[0]["ipackets"]

        #print("\npackets lost from 0 --> 1:   {0} pkts".format(lost_a))
        #print("packets lost from 1 --> 0:   {0} pkts".format(lost_b))

        #if (lost_a == 0) and (lost_b == 0):
        #    passed = True
        #else:
        #    passed = False

    except STLError as e:
        passed = False
        print(e)

    finally:
        c.disconnect()

    if passed:
        print("\nPASSED\n")
    else:
        print("\nFAILED\n")

def process_options ():
    parser = argparse.ArgumentParser(usage="""
    connect to TRex and send burst of packets

    examples

     stl_run_udp_simple.py -s 9001

     stl_run_udp_simple.py -s 9000 -d 2

     stl_run_udp_simple.py -s 3000 -d 3 -m 10mbps

     stl_run_udp_simple.py -s 3000 -d 3 -m 10mbps --debug

     then run the simulator on the output
       ./stl-sim -f example.yaml -o a.pcap  ==> a.pcap include the packet

    """,
    description="example for TRex api",
    epilog=" written by hhaim");

    parser.add_argument("-s", "--max-frame-size",
                        dest="frame_size",
                        help='L2 frame size in bytes without FCS',
                        default=60,
                        type = int,
                        )

    parser.add_argument("--ip",
                        dest="ip",
                        help='remote trex ip default local',
                        default="127.0.0.1",
                        type = str
                        )


    parser.add_argument('-d','--duration',
                        dest='duration',
                        help='duration in second ',
                        default=10,
                        type = int,
                        )


    parser.add_argument('-m','--multiplier',
                        dest='mul',
                        help='speed in gbps/pps for example 1gbps, 1mbps, 1mpps ',
                        default="1mbps"
                        )

    parser.add_argument('--debug',
                        action='store_true',
                        help='see debug into ')

    t_global.args = parser.parse_args();
    print(t_global.args)



def main():
    process_options ()
    throughputs = [
                    [64, "2mpps"],
                    [128, "2mpps"],
                    [256, "1.5mpps"],
                    [512, "1.5mpps"],
                    [1024, "1mpps"],
                    [1500, "1mpps"],
                    [3000, "1mpps"]
                    #[9000, "1kpps"]
                ]
    #throughputs = [
    #                [64, "3mpps"]
    #            ]
    duration = 60
    #print("======frame size {0} on ports 1, 3 for 10 seconds, UDP {1}...".format(speed, frame_size))
    print(f"{'port_id':<10} {'pkt_len':<10} {'cpu util':<10} {'tx_pps':<10} {'tx_bps':<10} {'tx_util':<10} {'rx_pps':<10} {'rx_bps':<10}")
    print('-' * 95)  # Print separator line for better visualization
    for throughput in throughputs:
        frame_size, speed = throughput
        simple_burst(duration = duration,
                     throughput = throughput
                     )
        time.sleep(10)

if __name__ == "__main__":
    main()